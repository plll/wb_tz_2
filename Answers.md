1) Какой самый эффективный способ конкатенации строк?
package main

```
import (
"strings"
"fmt"
)

func main() {
    var sb strings.Builder
    a := "21"
    b := "years"
    for i := 0; i < len(a) + len(b); i++ {
        sb.WriteString(a[i) // Пока не закончится а потом через иф по проверке индекса писать b
    }

    fmt.Println(sb.String())
}
```
2) Что такое интерфейсы, как они применяются в Go?
   Интерфейсный тип в Go — это своего рода определение. Он определяет и описывает конкретные методы, которые должны быть у какого-то другого типа. В Go они применяются в случае разделении приложения на слои, для легкой замены реализаций, ведь интерфейсы показывают лишь ожидаемые методы.
3) Чем отличаются RWMutex от Mutex?
 RWMutex дает возможность блокировать чтение и запись отдельно, поэтому например появляется возможность читать без блокировок
4) Чем отличаются буферизированные и не буферизированные каналы? 
   В буфферизированных каналах указывается размер буфера и горутина пишущая в него заблокируется только тогда, когда достигнет размера буфера, а чтение начнется только тогда когда будет достигнут предел буфера
5) Какой размер у структуры struct{}{}?
   0
6) Есть ли в Go перегрузка методов или операторов?
 Нет
7) В какой последовательности будут выведены элементы map[int]int?
 По возрастанию ключа
8) В чем разница make и new?
   make используяется для создание слайсов, мап, каналов, а также можно изначально указывать объем памяти для аллокации
   new возвращает указатель для инициализированной памяти
9) Сколько существует способов задать переменную типа slice или map?
 make([]int)
 var m2 []int
 x := []int{}
10) 1 
    1
 Так как сначала выведется указатель на ссылку, которая указывает на 1, а потом локально в функции апдейт заменится ссылка в p, но это не повлияет на переменную p в main
11) Будет неправильно отрабатывать код, тк мы передаем не ссылку на объект, а структуру wg.WaitGroup, которая внутри функции не будет никак взаимосвязана с внешней wg.WaitGroup и получается, что она никогда не проснется, тк wg.Done() не будут ничего делать с ней 
12) 0 Так как переменная определена локально в границах if 
13) 100 2 3 4 5 Так как копия слайса будет указывать на тот же массив, но функция append возвращает новый слайс, поэтому выведется без 6, тк в v будет произведен append только в локальной памяти функции
14) b b a
    a a 
    Так как функцией append мы создаем новый слайс, который не будет ссылаться на старый и его изменения будут выполнены только в локальной памяти внутри анонимной функции